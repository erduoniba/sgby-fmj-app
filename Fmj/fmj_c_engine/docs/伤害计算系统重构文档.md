# 伤害计算系统重构文档

## 概述

本文档基于FMJ引擎中的伤害计算代码分析，提供了完整的重构指南。原代码使用内存地址直接操作，重构后将使用结构化的面向对象设计。

## 原系统分析

### 内存布局（基于MCU_memory）

```c
// 玩家角色数据结构 (0x1988 + idx*0x19)
struct PlayerCharacter {
    // 0x00-0x10: 基础属性
    // 0x11: 指向详细属性的指针
};

// 敌人角色数据结构 (0x1826 + idx*0x33) 
struct EnemyCharacter {
    // 0x04: 普通攻击状态效果 [bit3:毒,bit2:乱,bit1:封,bit0:眠]
    // 0x12: 开始的详细属性数据
    // +0x01: 身法
    // +0x02: 灵力  
    // +0x08: 当前HP
    // +0x0E: 攻击力
    // +0x10: 防御力
    // +0x17: 持续效果回合数
};

// 属性增减益 (玩家: 0x1800 + idx*5, 敌人: 0x180F + idx*5)
struct AttributeModifier {
    // +0x00: 攻击增减益
    // +0x02: 防御增减益  
    // +0x04: 身法增减益
};
```

### 核心伤害计算逻辑

## 重构设计

### 1. 数据结构设计

```typescript
// 角色基础接口
interface ICharacter {
  id: string;
  level: number;
  hp: number;
  maxHp: number;
  mp: number;
  maxMp: number;
  attack: number;
  defense: number;
  agility: number;     // 身法
  spirit: number;      // 灵力
  luck: number;        // 幸运
}

// 玩家角色
class PlayerCharacter implements ICharacter {
  id: string;
  level: number;
  hp: number;
  maxHp: number;
  mp: number;
  maxMp: number;
  attack: number;
  defense: number;
  agility: number;
  spirit: number;
  luck: number;
  
  // 玩家特有属性
  experience: number;
  money: number;
  equipment: Equipment[];
}

// 敌人角色
class EnemyCharacter implements ICharacter {
  id: string;
  level: number;
  hp: number;
  maxHp: number;
  mp: number;
  maxMp: number;
  attack: number;
  defense: number;
  agility: number;
  spirit: number;
  luck: number;
  
  // 敌人特有属性
  statusEffects: StatusEffectType; // 普通攻击可产生的状态效果
  effectDuration: number;          // 效果持续回合数
}

// 属性修正值
interface AttributeModifiers {
  attack: number;
  defense: number;
  agility: number;
}

// 状态效果类型
enum StatusEffectType {
  SLEEP = 1,    // 眠 (bit0)
  SEAL = 2,     // 封 (bit1) 
  CONFUSE = 4,  // 乱 (bit2)
  POISON = 8    // 毒 (bit3)
}
```

### 2. 伤害计算系统

```typescript
class DamageCalculator {
  private random: RandomGenerator;
  
  constructor(random: RandomGenerator) {
    this.random = random;
  }

  /**
   * 计算普通攻击伤害（敌人攻击玩家）
   */
  calculateNormalAttackDamage(
    attacker: EnemyCharacter,
    defender: PlayerCharacter,
    attackerModifiers: AttributeModifiers,
    defenderModifiers: AttributeModifiers
  ): AttackResult {
    
    // 1. 计算命中检测
    const hitResult = this.calculateHitChance(
      attacker, defender, attackerModifiers, defenderModifiers
    );
    
    if (!hitResult.isHit) {
      return {
        damage: 0,
        isMiss: true,
        statusEffects: []
      };
    }
    
    // 2. 计算基础伤害
    const finalAttack = attacker.attack + attackerModifiers.attack;
    const finalDefense = defender.defense + defenderModifiers.defense;
    
    // 原公式: damage = attack / ((defense >> 3) + 1) + random % ((attack >> 4) + 1)
    let baseDamage = Math.floor(finalAttack / ((finalDefense >> 3) + 1));
    baseDamage += this.random.next() % ((finalAttack >> 4) + 1);
    
    // 3. 特殊减伤检测（原代码中的特殊条件）
    if (this.hasSpecialDefense(defender)) {
      baseDamage = Math.floor(baseDamage / 2);
    }
    
    // 4. 应用伤害
    const actualDamage = Math.min(baseDamage, defender.hp);
    
    // 5. 计算状态效果
    const statusEffects = this.calculateStatusEffects(attacker);
    
    return {
      damage: actualDamage,
      isMiss: false,
      statusEffects
    };
  }

  /**
   * 计算命中率
   */
  private calculateHitChance(
    attacker: EnemyCharacter,
    defender: PlayerCharacter,
    attackerModifiers: AttributeModifiers,
    defenderModifiers: AttributeModifiers
  ): { isHit: boolean } {
    
    // 玩家身法 = 玩家身法增减益 + 玩家角色身法 + 50
    const playerAgility = defenderModifiers.agility + defender.agility + 50;
    
    // 敌人身法 = 敌人身法增减益 + 敌人角色身法
    const enemyAgility = attackerModifiers.agility + attacker.agility;
    
    // 计算身法差值
    let agilityDiff;
    if (playerAgility > enemyAgility) {
      agilityDiff = playerAgility - enemyAgility;
    } else {
      agilityDiff = 10; // 最小命中率保底
    }
    
    // 命中检测: random % 200 < agilityDiff
    const hitRoll = this.random.next() % 200;
    return { isHit: hitRoll < agilityDiff };
  }

  /**
   * 特殊防护检测
   */
  private hasSpecialDefense(defender: PlayerCharacter): boolean {
    // 原代码条件: MCU_memory[*(UINT16*)(MCU_memory+(_17CC<<1)+0x181E)] == 0x05 || MCU_memory[_17CC+0x1916]
    // 这里需要根据具体游戏逻辑来实现，可能是装备效果或状态效果
    return false; // 临时实现
  }

  /**
   * 计算状态效果
   */
  private calculateStatusEffects(attacker: EnemyCharacter): StatusEffect[] {
    const effects: StatusEffect[] = [];
    
    if (attacker.statusEffects & StatusEffectType.SLEEP) {
      effects.push({
        type: StatusEffectType.SLEEP,
        duration: attacker.effectDuration
      });
    }
    
    if (attacker.statusEffects & StatusEffectType.SEAL) {
      effects.push({
        type: StatusEffectType.SEAL,
        duration: attacker.effectDuration
      });
    }
    
    if (attacker.statusEffects & StatusEffectType.CONFUSE) {
      effects.push({
        type: StatusEffectType.CONFUSE,
        duration: attacker.effectDuration
      });
    }
    
    if (attacker.statusEffects & StatusEffectType.POISON) {
      effects.push({
        type: StatusEffectType.POISON,
        duration: attacker.effectDuration
      });
    }
    
    return effects;
  }

  /**
   * 计算魔法伤害
   */
  calculateMagicDamage(
    caster: ICharacter,
    targets: ICharacter[],
    spellDamage: SpellDamage,
    casterModifiers: AttributeModifiers
  ): MagicAttackResult[] {
    
    const results: MagicAttackResult[] = [];
    
    for (const target of targets) {
      // 基础魔法伤害
      let magicDamage = spellDamage.hpDamage;
      
      // 加入施法者灵力加成
      magicDamage += caster.spirit * (magicDamage >> 6);
      
      // 减去目标灵力抗性  
      magicDamage -= target.spirit * (magicDamage >> 6);
      
      // 随机浮动
      const randomValue = this.random.next();
      magicDamage += (randomValue % magicDamage) >> 4;
      
      // 计算实际伤害
      const actualDamage = Math.min(magicDamage, target.hp);
      
      results.push({
        target,
        hpDamage: actualDamage,
        mpDamage: spellDamage.mpDamage,
        isHeal: spellDamage.hpDamage < 0 // 负数表示治疗
      });
    }
    
    return results;
  }
}

// 攻击结果
interface AttackResult {
  damage: number;
  isMiss: boolean;
  statusEffects: StatusEffect[];
}

// 魔法攻击结果
interface MagicAttackResult {
  target: ICharacter;
  hpDamage: number;
  mpDamage: number;
  isHeal: boolean;
}

// 状态效果
interface StatusEffect {
  type: StatusEffectType;
  duration: number;
}

// 法术伤害定义
interface SpellDamage {
  hpDamage: number; // 正数伤害，负数治疗
  mpDamage: number;
}

// 随机数生成器接口
interface RandomGenerator {
  next(): number;
}
```

### 3. 战斗管理器

```typescript
class BattleManager {
  private damageCalculator: DamageCalculator;
  private players: PlayerCharacter[];
  private enemies: EnemyCharacter[];
  private playerModifiers: AttributeModifiers[];
  private enemyModifiers: AttributeModifiers[];
  
  constructor(random: RandomGenerator) {
    this.damageCalculator = new DamageCalculator(random);
    this.players = [];
    this.enemies = [];
    this.playerModifiers = [];
    this.enemyModifiers = [];
  }
  
  /**
   * 执行敌人攻击玩家
   */
  executeEnemyAttack(enemyIndex: number, playerIndex: number): AttackResult {
    const attacker = this.enemies[enemyIndex];
    const defender = this.players[playerIndex];
    const attackerMods = this.enemyModifiers[enemyIndex];
    const defenderMods = this.playerModifiers[playerIndex];
    
    const result = this.damageCalculator.calculateNormalAttackDamage(
      attacker, defender, attackerMods, defenderMods
    );
    
    // 应用伤害
    if (!result.isMiss) {
      defender.hp = Math.max(0, defender.hp - result.damage);
      
      // 应用状态效果
      this.applyStatusEffects(defender, result.statusEffects);
    }
    
    return result;
  }
  
  /**
   * 执行魔法攻击
   */
  executeMagicAttack(
    casterId: string, 
    targetIds: string[], 
    spellDamage: SpellDamage
  ): MagicAttackResult[] {
    
    const caster = this.findCharacter(casterId);
    const targets = targetIds.map(id => this.findCharacter(id));
    const casterMods = this.getCharacterModifiers(casterId);
    
    const results = this.damageCalculator.calculateMagicDamage(
      caster, targets, spellDamage, casterMods
    );
    
    // 应用伤害/治疗
    for (const result of results) {
      if (result.isHeal) {
        result.target.hp = Math.min(
          result.target.maxHp, 
          result.target.hp + Math.abs(result.hpDamage)
        );
      } else {
        result.target.hp = Math.max(0, result.target.hp - result.hpDamage);
      }
      
      result.target.mp = Math.max(0, result.target.mp - result.mpDamage);
    }
    
    return results;
  }
  
  private findCharacter(id: string): ICharacter {
    // 实现角色查找逻辑
    throw new Error("Not implemented");
  }
  
  private getCharacterModifiers(id: string): AttributeModifiers {
    // 实现修正值查找逻辑
    throw new Error("Not implemented");
  }
  
  private applyStatusEffects(target: ICharacter, effects: StatusEffect[]): void {
    // 实现状态效果应用逻辑
    throw new Error("Not implemented");
  }
}
```

### 4. 属性上限管理

```typescript
class AttributeManager {
  // 属性上限常量
  static readonly MAX_HP = 9999;
  static readonly MAX_MP = 9999;
  static readonly MAX_ATTACK = 999;
  static readonly MAX_DEFENSE = 999;
  static readonly MAX_AGILITY = 99;
  static readonly MAX_SPIRIT = 99;
  static readonly MAX_LUCK = 99;
  
  /**
   * 规范化角色属性，确保不超过上限
   */
  static normalizeAttributes(character: ICharacter): void {
    // HP和MP不超过最大值
    character.hp = Math.min(character.hp, character.maxHp);
    character.mp = Math.min(character.mp, character.maxMp);
    
    // 各属性不超过上限
    character.maxHp = Math.min(character.maxHp, this.MAX_HP);
    character.maxMp = Math.min(character.maxMp, this.MAX_MP);
    character.attack = Math.min(character.attack, this.MAX_ATTACK);
    character.defense = Math.min(character.defense, this.MAX_DEFENSE);
    character.agility = Math.min(character.agility, this.MAX_AGILITY);
    character.spirit = Math.min(character.spirit, this.MAX_SPIRIT);
    character.luck = Math.min(character.luck, this.MAX_LUCK);
  }
}
```

## 重构要点

### 1. 代码优化
- **消除魔法数字**: 所有硬编码的数值都定义为常量
- **类型安全**: 使用TypeScript提供编译时类型检查
- **函数拆分**: 将复杂逻辑拆分为独立的、可测试的函数

### 2. 可扩展性
- **接口设计**: 使用接口便于扩展不同类型的角色
- **策略模式**: 不同的伤害计算可以实现不同的策略
- **事件系统**: 可以轻松添加战斗事件监听

### 3. 可测试性
- **依赖注入**: RandomGenerator可以注入模拟对象进行测试
- **纯函数**: 大部分计算逻辑都是纯函数，便于单元测试
- **状态隔离**: 每个计算都基于传入参数，避免隐含状态

### 4. 性能考虑
- **对象池**: 在频繁战斗中可以使用对象池减少GC压力
- **缓存计算**: 对于不变的属性计算结果可以缓存
- **批量处理**: 群体攻击使用批量处理提高效率

## 迁移指南

1. **数据迁移**: 将MCU_memory中的数据结构迁移到新的类结构
2. **逻辑迁移**: 逐个函数迁移，保持原有的游戏逻辑不变
3. **测试验证**: 使用原系统的测试用例验证新系统的正确性
4. **性能调优**: 根据实际运行情况进行性能优化

## 总结

此重构文档提供了从低级内存操作到现代面向对象设计的完整迁移方案。新系统保持了原有的游戏逻辑，同时提供了更好的可维护性、可扩展性和可测试性。